#!/usr/bin/env python3
import os 
import argparse
import sys
import math

def parse_arguments(non_interactive_arguments=None):
    parser = argparse.ArgumentParser(prog='orasp',
                                     description='ORCA spectrum parser')
    parser.add_argument('orca_output', type=open,
                        help='''Output file of the ORCA calculation w/ the spectrum''')
    parser.add_argument('-o', nargs='?', type=argparse.FileType('w'),
                        metavar='OUTFILE', default=sys.stdout,
                        help='Output of the script. Default is stdout.')
    parser.add_argument('-spectype', choices=['v', 'l', 'm', 'f'], 
                        metavar='SPECTYPE', default='l',
                        help='Type of spectrum to plot. v, \
                              l and m are velocity, length \
                              magnetic transitions. use f for TINT keyword.')
    parser.add_argument('--units', choices=['cm', 'ev', 'nm'], 
                        metavar='UNIT', default='cm',
                        help='Units for the specturm. Default nm')
    parser.add_argument('-py', type=str, default=False,
                        help='Output in python format. \
                              Optionally can specify the dict name',
                        nargs='?')
    parser.add_argument('-thermal', type=int,
                        help='Perform thermal averaging. Specify T.',
                        metavar='TEMP')
    parser.add_argument('--roots-only', action='store_true',
                        help='only print the roots')
    if non_interactive_arguments == None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(non_interactive_arguments)
    if args.spectype in ['v', 'm', 'f']:
        args.trdc = False
    args.filename = args.orca_output.name
    return args


def get_roots(args):
    roots = {}
    started = 0
    flag_line = 'QDPT WITH NEVPT2 DIAGONAL ENERGIES'
    for line in args.orca_output:
        if flag_line in line:
            break
    flag_line = 'Eigenvalues:'
    for line in args.orca_output:
        if flag_line in line:
            break
    for line in args.orca_output:
        if 'threshold' in line.lower(): break
        if not line.split(): continue
        state, e_cm, e_ev, *rest = line.split()
        roots[state.strip(':')] = {'cm': e_cm, 'ev': e_ev}
    args.roots = roots
    return roots


def get_spectrum(args):
    roots = {}
    spec_lines = {'l': '++ Dipole transition strengths',
                  'v': '++ Velocity transition strengths',
                  'm': '++ Magnetic-Dipole',
                  'f':  '++ Isotropic transition moment strengths (SO states):'}
    flag_line = spec_lines[args.spectype]
    started = 0
    spectrum = {}
    for line in args.orca_output:
        if flag_line in line:
            started = 1
        if not started or not line.split(): continue
        if line.split()[0] == '--': 
            break
        try:
            initial, final, osc_str, *rest = line.split()
            initial, final = map(int, (initial, final))
            osc_str = float(osc_str)
            osc_str *= args.populations[initial]
            delta_e = args.roots[final] - args.roots[initial]
            dipole_matrix_element = (osc_str * 1.5) / delta_e
            delta_e_ev = delta_e * 27.211396641308
            delta_e_cm = ((delta_e_ev * 1.602177e-19)/(6.62607015e-34 * 299792458)) / 100
            delta_e_nm = 1/delta_e_cm * 10e6
            e = {'ev': delta_e_ev,
                 'cm': delta_e_cm, 
                 'nm': delta_e_nm}
            spectrum[f'{initial}->{final}'] = (e[args.units], osc_str, dipole_matrix_element)
        except ValueError:
            continue
    args.spectrum = {k: v for k, v in sorted(spectrum.items(), key=lambda item: item[1][0])} #sort by e
    return spectrum


def get_spectrum_trdc(args):
    args.spectrum = {}
    roots = {}
    flag_line = '++ Complex transition dipole vectors'
    started = 0
    spectrum = {}
    for line in args.orca_output:
        if flag_line in line:
            started = 1
        if not started or not line.split(): continue
        if line.split()[0] == '--': 
            break
        try:
            initial, final, x_r, x_i, y_r, y_i, z_r, z_i = line.split()
            x = complex(float(x_r), float(x_i))
            y = complex(float(y_r), float(y_i))
            z = complex(float(z_r), float(z_i))
            initial, final = map(int, (initial, final))
            dipole_matrix_element = x*x.conjugate() + y*y.conjugate() + z*z.conjugate()
            dipole_matrix_element = dipole_matrix_element.real
            delta_e = args.roots[final] - args.roots[initial]
            osc_str = (2/3) * dipole_matrix_element * delta_e
            osc_str *= args.populations[initial]
            delta_e_ev = delta_e * 27.211396641308
            delta_e_cm = ((delta_e_ev * 1.602177e-19)/(6.62607015e-34 * 299792458)) / 100
            delta_e_nm = 1/delta_e_cm * 10e6
            e = {'ev': delta_e_ev,
                 'cm': delta_e_cm, 
                 'nm': delta_e_nm}
            spectrum[f'{initial}->{final}'] = (e[args.units], osc_str, dipole_matrix_element)
        except ValueError:
            continue
    args.spectrum = {k: v for k, v in sorted(spectrum.items(), key=lambda item: item[1][0])}
    return spectrum


def compute_populations(args):
    """given the dict of roots, computes populations for all of them"""
    if not args.thermal:
        args.populations = {k:v for k,v in zip(args.roots, [1 for x in args.roots])}
        return
    gs = args.roots[1]
    k = 8.617333262e-5 
    beta = 1 / (k*args.thermal)
    args.populations = {}
    for state, energy in args.roots.items():
        gap = energy - gs
        gap *= 27.211396641308
        args.populations[state] = math.exp(-(gap) * beta)
    return 


def print_spectrum(args):
    if args.py is False:
        print(f'transition', f'energy_{args.units}', 'osc_str', '<i|mu|f>^2',
              file=args.o, sep=',')
        for k, v in args.spectrum.items():
            print(k, v[0], v[1], v[2], file=args.o, sep=',')
        return
    dict_name = args.spectype if args.py == None else args.py
    print(f'data_{dict_name} = ', '{', file=args.o)
    for k, v in args.spectrum.items():
        print(' '*4, f"'{k}' : ", 
              '{', 
              f"'energy_{args.units}': {v[0]}, 'osc_str': {v[1]}, 'dipole_matrix_element': {v[2]}", 
              '},',
              file=args.o)
    print('}', file=args.o)


def main(non_interactive_arguments=None):
    args = parse_arguments(non_interactive_arguments)
    roots = get_roots(args)
    if not roots:
        print('Error in parsing roots!')
        return 1
    elif args.roots_only:
        #print roots, convert to cm
        print('root', 'e_cm', 'e_ev', sep=',', file=args.o)
        [print(_[0], _[1]['cm'], _[1]['ev'], sep=',', file=args.o) for _ in roots.items()]
        args.orca_output.close()
        return 0
    return 0


if __name__ == '__main__':
    exit(main())

