#!/usr/bin/env python3
import os 
import argparse
import sys
import math

def parse_arguments(non_interactive_arguments=None):
    parser = argparse.ArgumentParser(prog='orasp',
                                     description='ORCA spectrum parser')
    parser.add_argument('orca_output', type=open,
                        help='''Output file of the ORCA calculation''')
    parser.add_argument('-o', nargs='?', type=argparse.FileType('w'), metavar='OUTFILE', default=sys.stdout,
                        help='Output of the script. Default is stdout.')
    parser.add_argument('-spectype', choices=['v', 'l', 'f'], 
                        metavar='SPECTYPE', default='l',
                        help='Type of spectrum to plot. v, \
                              and l are velocity, length \
                              transitions. use f for full semiclassical transitions.')
    parser.add_argument('--units', choices=['cm', 'ev', 'nm'], 
                        metavar='UNIT', default='cm',
                        help='Units for the specturm. Default cm')
    parser.add_argument('-noso', action='store_true',
                        help='Do not use spin-orbit.')
    parser.add_argument('-py', type=str, default=False,
                        help='Output in python format. \
                              Optionally can specify the dict name',
                        nargs='?')
    parser.add_argument('--roots-only', action='store_true',
                        help='only print the roots')
    parser.add_argument('--g-factors', action='store_true',
                        help='only print the g-factors')
    parser.add_argument('--zeta', action='store_true',
                        help='only print the zeta')
    parser.add_argument('--soc-info', action='store_true',
                        help='print the soc info for casscf and caspt2')
    if non_interactive_arguments == None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(non_interactive_arguments)
    args.so = False if args.noso else True
    args.filename = args.orca_output.name
    return args

def get_roots(args):
    roots = {}
    started = 0
    while True: 
        line = next(args.orca_output)
        if 'Using One-Photon Spectroscopy Tool' in line: 
            for i in range(5): next(args.orca_output)
            break
    for line in args.orca_output:
        if not line.split(): break
        rootnum, colon, energy, *rest = line.split()
        roots[rootnum] = energy
    args.roots = roots
    return roots

def get_g_factors(args):
    while 1:
        line = next(args.orca_output)
        if 'ELECTRONIC G-MATRIX' in line and len(line) < 47:
            for i in range(19): next(args.orca_output)
            break
    return next(args.orca_output).split()


def get_zeta(args):
    zeta = 0
    root_collection = []
    while 1:
        line = next(args.orca_output)
        if 'The ligand field one electron eigenfunctions:' in line:
            next(args.orca_output)
            next(args.orca_output)
            for i in range(7):
                root_collection.append(next(args.orca_output).split()[2])
            root_collection = [].copy()
            break
    while 1:
        line = next(args.orca_output)
        if 'The ligand field one electron eigenfunctions:' in line:
            next(args.orca_output)
            next(args.orca_output)
            for i in range(7):
                root_collection.append(next(args.orca_output).split()[2])
            break
    while 1:
        line = next(args.orca_output)
        if 'ZETA_F' in line:
            zeta = float(line.split()[-1])
            break
    return zeta, list(map(float, root_collection))


def seek(file_iterator, target_line):
    line = next(file_iterator)
    while target_line not in line:
        line = next(file_iterator)
    return line

def parse_one_soc_state(file_iterator, current_state, states_dict):
    current_state_dict = states_dict[current_state]
    line = next(file_iterator)
    # parse the weights
    while 'STATE' not in line:
        weight, real, im, colon, block, root, spin, ms = line.split()
        if ms == '1/2': current_state_dict[int(root)][1] = float(weight)
        if ms == '-1/2': current_state_dict[int(root)][0] = float(weight)
        line = next(file_iterator)
        if 'Passed SOC' in line: return False
    return True


def get_soc_info(args):
    """
    Generates the following datastructure:
    casscf_states = {
        1: {'energy': state_energy, 0: [m_s=-1/2 weight, m_s=1/2 weight], 1: [m_s=-1/2 weight, m_s=1/2 weight], 2:............
        2: {'energy': state_energy, 0: [m_s=-1/2 weight, m_s=1/2 weight], 1: [m_s=-1/2 weight, m_s=1/2 weight], 2:............
        ........................
        13: {'energy': state_energy, 0: [m_s=-1/2 weight, m_s=1/2 weight], 1: [m_s=-1/2 weight, m_s=1/2 weight], 2:............
    }
    """
    # initialize the datastructure
    casscf_states, nevpt2_states = dict(), dict()
    for root in range(14):
        casscf_states[root] = {'energy_abs': 0, 'energy': 0,}
        nevpt2_states[root] = {'energy_abs': 0, 'energy': 0,}
        for r2 in range(7):
            casscf_states[root][r2] = [0, 0]
            nevpt2_states[root][r2] = [0, 0]
    # parse the abs gs energy
    casscf_abs_e = float(seek(args.orca_output, 'Lowest eigenvalue of the SOC matrix:').split()[-2]) * 219474.63137
    # parse the relative energies
    seek(args.orca_output, 'Eigenvalues:')
    for root in range(14):
        casscf_states[root]['energy'] = float(next(args.orca_output).split()[1])
        casscf_states[root]['energy_abs'] = casscf_states[root]['energy'] + casscf_abs_e
    # parse the weights
    seek(args.orca_output, 'Eigenvectors:')
    next(args.orca_output)
    next(args.orca_output)
    current_state = 0
    while parse_one_soc_state(args.orca_output, current_state, casscf_states):
        current_state += 1
    #### NEVPT2 block 
    # parse the abs energy
    nevpt2_abs_e = float(seek(args.orca_output, 'Lowest eigenvalue of the SOC matrix:').split()[-2]) * 219474.63137
    #parse the rel energy
    seek(args.orca_output, 'Eigenvalues:')
    for root in range(14):
        nevpt2_states[root]['energy'] = float(next(args.orca_output).split()[1])
        nevpt2_states[root]['energy_abs'] = nevpt2_states[root]['energy'] + nevpt2_abs_e
    seek(args.orca_output, 'Eigenvectors:')
    next(args.orca_output)
    next(args.orca_output)
    current_state = 0
    while parse_one_soc_state(args.orca_output, current_state, nevpt2_states):
        current_state += 1
    return casscf_states, nevpt2_states


def parse_orca_spectrum(file_iterator, spec_line):
    spectrum = dict()
    # seek the spectrum desired
    while True:
        current_line = next(file_iterator)
        if spec_line in current_line: 
            for i in range(4): 
                next(file_iterator)
            break 
    # parse the spectrum
    current_line = next(file_iterator)
    while '*' not in current_line and current_line.split():
        init, arrow, final, e_ev, e_cm, wavelength, fosc, matrix_element, *rest = current_line.split()
        init, final = init[:-5], final[:-5]
        init, final = str(int(init) + 1), str(int(final) + 1)
        spectrum[init+arrow+final] = {'e_cm': float(e_cm), 'fosc*pop': float(fosc), 'matrix_element': float(matrix_element)}
        current_line = next(file_iterator)
    return spectrum


def print_spectrum(args):
    if args.py is False:
        print(f'transition', f'energy_{args.units}', 'osc_str', '<i|mu|f>^2',
              file=args.o, sep=',')
        for k, v in args.spectrum.items():
            print(k, v['e_cm'], v['fosc*pop'], v['matrix_element'], file=args.o, sep=',')
        return
    dict_name = args.spectype if args.py == None else args.py
    print(f'data_{dict_name} = ', '{', file=args.o)
    for k, v in args.spectrum.items():
        print(' '*4, f"'{k}' : ", 
              '{', 
              f"'energy_{args.units}': {v[0]}, 'osc_str': {v[1]}, 'dipole_matrix_element': {v[2]}", 
              '},',
              file=args.o)
    print('}', file=args.o)


def main(non_interactive_arguments=None):
    args = parse_arguments(non_interactive_arguments)
    if args.zeta:
        z, ailft_roots = get_zeta(args)
        return z, ailft_roots
    if args.g_factors:
        g=get_g_factors(args)
        return g
    if args.soc_info:
        return get_soc_info(args)
    roots = get_roots(args)
    roots = get_roots(args)
    if not roots:
        return 1
    elif args.roots_only:
        #print roots, convert to cm
        args.orca_output.close()
        [print(_, file=args.o) for _ in args.roots.values()]
        return args.roots
    spec_options = {
        'l': 'TRANSITION ELECTRIC DIPOLE MOMENTS',
        'v': 'TRANSITION VELOCITY DIPOLE MOMENTS',
        'f': 'FULL SEMI-CLASSICAL FORMULATION'
    }
    spec_line = 'SOC CORRECTED ABSORPTION SPECTRUM VIA ' + spec_options[args.spectype] + ' (- Extended -)'
    args.spectrum = parse_orca_spectrum(args.orca_output, spec_line)
    args.orca_output.close()
    if non_interactive_arguments != None and args.o == sys.stdout:
        return args.spectrum
    print_spectrum(args)
    return args.spectrum


if __name__ == '__main__':
    main()
