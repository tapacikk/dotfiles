#!/usr/bin/env python3
import os 
import argparse
import sys
import math

def parse_arguments(non_interactive_arguments=None):
    parser = argparse.ArgumentParser(prog='orasp',
                                     description='ORCA spectrum parser')
    parser.add_argument('orca_output', type=open,
                        help='''Output file of the ORCA calculation''')
    parser.add_argument('-o', nargs='?', type=argparse.FileType('w'), metavar='OUTFILE', default=sys.stdout,
                        help='Output of the script. Default is stdout.')
    parser.add_argument('-spectype', choices=['v', 'l', 'f'], 
                        metavar='SPECTYPE', default='l',
                        help='Type of spectrum to plot. v, \
                              and l are velocity, length \
                              transitions. use f for full semiclassical transitions.')
    parser.add_argument('--units', choices=['cm', 'ev', 'nm'], 
                        metavar='UNIT', default='cm',
                        help='Units for the specturm. Default cm')
    parser.add_argument('-noso', action='store_true',
                        help='Do not use spin-orbit.')
    parser.add_argument('-py', type=str, default=False,
                        help='Output in python format. \
                              Optionally can specify the dict name',
                        nargs='?')
    parser.add_argument('--roots-only', choices=['cas', 'nevpt2'],
                        help='only print the roots')
    parser.add_argument('--g-factors', action='store_true',
                        help='only print the g-factors')
    parser.add_argument('--zeta', choices=['cas', 'nevpt2'],
                        help='only print the zeta')
    parser.add_argument('--soc-info', action='store_true',
                        help='print the soc info for casscf and caspt2')
    if non_interactive_arguments == None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(non_interactive_arguments)
    args.so = False if args.noso else True
    args.filename = args.orca_output.name
    return args

def get_roots(file_iter):
    roots = {}
    soc_line = 'Lowest eigenvalue of the SOC matrix:'
    started = 0
    roots['ref_e'] = float(seek(file_iter, soc_line).split()[-2])
    seek(file_iter, 'Using One-Photon Spectroscopy Tool')
    skip(file_iter, 5)
    for line in file_iter:
        if not line.split(): break
        rootnum, colon, energy, *rest = line.split()
        roots[rootnum] = energy
    return roots

def get_g_factors(args):
    while 1:
        line = next(args.orca_output)
        if 'ELECTRONIC G-MATRIX' in line and len(line) < 47:
            for i in range(19): next(args.orca_output)
            break
    return next(args.orca_output).split()


def get_zeta(output_iter, method):
    zeta = 0
    root_collection = []
    ailft_line = 'The ligand field one electron eigenfunctions:'
    zeta_line = 'ZETA_F'
    # parse cas ailft roots
    seek(output_iter, ailft_line)
    skip(output_iter, 2)
    for i in range(7):
        root_collection.append(next(output_iter).split()[2])
    skip(output_iter, 6)
    reference_e = float(next(output_iter).split()[-2])
    if method == 'cas':
        zeta = float(seek(output_iter, zeta_line).split()[-1])
        return zeta, list(map(float, root_collection)), reference_e
    root_collection = [].copy()
    refrence_e = 0
    #parse nevpt2 ailft roots
    seek(output_iter, ailft_line)
    skip(output_iter, 2)
    for i in range(7):
        root_collection.append(next(output_iter).split()[2])
    skip(output_iter, 6)
    reference_e = float(next(output_iter).split()[-2])
    zeta = float(seek(output_iter, zeta_line).split()[-1])
    return zeta, list(map(float, root_collection)), reference_e


def seek(file_iterator, target_line):
    line = next(file_iterator)
    while target_line not in line:
        line = next(file_iterator)
    return line

# skip: skip n lines in the iterator
def skip(file_iterator, n):
    for i in range(n): 
        next(file_iterator)

def parse_one_soc_state(file_iterator, current_state, states_dict):
    current_state_dict = states_dict[current_state]
    line = next(file_iterator)
    # parse the weights
    while 'STATE' not in line:
        weight, real, im, colon, block, root, spin, ms = line.split()
        if ms == '1/2': current_state_dict[int(root)][1] = float(weight)
        if ms == '-1/2': current_state_dict[int(root)][0] = float(weight)
        line = next(file_iterator)
        if 'Passed SOC' in line: return False
    return True


def get_soc_info(args):
    """
    Generates the following datastructure:
    casscf_states = {
        1: {'energy': state_energy, 0: [m_s=-1/2 weight, m_s=1/2 weight], 1: [m_s=-1/2 weight, m_s=1/2 weight], 2:............
        2: {'energy': state_energy, 0: [m_s=-1/2 weight, m_s=1/2 weight], 1: [m_s=-1/2 weight, m_s=1/2 weight], 2:............
        ........................
        13: {'energy': state_energy, 0: [m_s=-1/2 weight, m_s=1/2 weight], 1: [m_s=-1/2 weight, m_s=1/2 weight], 2:............
    }
    """
    # initialize the datastructure
    casscf_states, nevpt2_states = dict(), dict()
    for root in range(14):
        casscf_states[root] = {'energy_abs': 0, 'energy': 0,}
        nevpt2_states[root] = {'energy_abs': 0, 'energy': 0,}
        for r2 in range(7):
            casscf_states[root][r2] = [0, 0]
            nevpt2_states[root][r2] = [0, 0]
    # parse the abs gs energy
    casscf_abs_e = float(seek(args.orca_output, 'Lowest eigenvalue of the SOC matrix:').split()[-2]) * 219474.63137
    # parse the relative energies
    seek(args.orca_output, 'Eigenvalues:')
    for root in range(14):
        casscf_states[root]['energy'] = float(next(args.orca_output).split()[1])
        casscf_states[root]['energy_abs'] = casscf_states[root]['energy'] + casscf_abs_e
    # parse the weights
    seek(args.orca_output, 'Eigenvectors:')
    next(args.orca_output)
    next(args.orca_output)
    current_state = 0
    while parse_one_soc_state(args.orca_output, current_state, casscf_states):
        current_state += 1
    #### NEVPT2 block 
    # parse the abs energy
    nevpt2_abs_e = float(seek(args.orca_output, 'Lowest eigenvalue of the SOC matrix:').split()[-2]) * 219474.63137
    #parse the rel energy
    seek(args.orca_output, 'Eigenvalues:')
    for root in range(14):
        nevpt2_states[root]['energy'] = float(next(args.orca_output).split()[1])
        nevpt2_states[root]['energy_abs'] = nevpt2_states[root]['energy'] + nevpt2_abs_e
    seek(args.orca_output, 'Eigenvectors:')
    next(args.orca_output)
    next(args.orca_output)
    current_state = 0
    while parse_one_soc_state(args.orca_output, current_state, nevpt2_states):
        current_state += 1
    return casscf_states, nevpt2_states


def parse_orca_spectrum(file_iterator, spec_line):
    spectrum = dict()
    # seek the spectrum desired
    while True:
        current_line = next(file_iterator)
        if spec_line in current_line: 
            for i in range(4): 
                next(file_iterator)
            break 
    # parse the spectrum
    current_line = next(file_iterator)
    while '*' not in current_line and current_line.split():
        init, arrow, final, e_ev, e_cm, wavelength, fosc, matrix_element, *rest = current_line.split()
        init, final = init[:-5], final[:-5]
        init, final = str(int(init) + 1), str(int(final) + 1)
        spectrum[init+arrow+final] = {'e_cm': float(e_cm), 'fosc*pop': float(fosc), 'matrix_element': float(matrix_element)}
        current_line = next(file_iterator)
    return spectrum


def print_spectrum(args):
    if args.py is False:
        print(f'transition', f'energy_{args.units}', 'osc_str', '<i|mu|f>^2',
              file=args.o, sep=',')
        for k, v in args.spectrum.items():
            print(k, v['e_cm'], v['fosc*pop'], v['matrix_element'], file=args.o, sep=',')
        return
    dict_name = args.spectype if args.py == None else args.py
    print(f'data_{dict_name} = ', '{', file=args.o)
    for k, v in args.spectrum.items():
        print(' '*4, f"'{k}' : ", 
              '{', 
              f"'energy_{args.units}': {v[0]}, 'osc_str': {v[1]}, 'dipole_matrix_element': {v[2]}", 
              '},',
              file=args.o)
    print('}', file=args.o)


def main(non_interactive_arguments=None):
    args = parse_arguments(non_interactive_arguments)
    cas_roots = get_roots(args.orca_output)
    nevpt2_roots = get_roots(args.orca_output)
    if not cas_roots or not nevpt2_roots:
        return 1
    if args.zeta:
        z, ailft_roots, reference_e = get_zeta(args.orca_output, args.zeta)
        root_dict = cas_roots if args.zeta == 'cas' else nevpt2_roots
        root00 = root_dict['ref_e']
        if non_interactive_arguments == None:
            print(z, ailft_roots, reference_e, root00, file=args.o)
        return z, ailft_roots, reference_e, root00
    if args.g_factors:
        g=get_g_factors(args)
        return g
    if args.soc_info:
        return get_soc_info(args)
    elif args.roots_only:
        args.orca_output.close()
        root_dict = cas_roots if args.roots_only == 'cas' else nevpt2_roots
        [print(_, file=args.o) for _ in root_dict.values()]
        return root_dict
    spec_options = {
        'l': 'TRANSITION ELECTRIC DIPOLE MOMENTS',
        'v': 'TRANSITION VELOCITY DIPOLE MOMENTS',
        'f': 'FULL SEMI-CLASSICAL FORMULATION'
    }
    spec_line = 'SOC CORRECTED ABSORPTION SPECTRUM VIA ' + spec_options[args.spectype] + ' (- Extended -)'
    args.spectrum = parse_orca_spectrum(args.orca_output, spec_line)
    args.orca_output.close()
    if non_interactive_arguments != None and args.o == sys.stdout:
        return args.spectrum
    print_spectrum(args)
    return args.spectrum


if __name__ == '__main__':
    main()
